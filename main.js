/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => DateSelectorPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  outputFormat: "MM/DD/YYYY"
  // Default to US format
};
var DATE_FORMATS = {
  "US Format (MM/DD/YYYY)": "MM/DD/YYYY",
  "International (YYYY-MM-DD)": "YYYY-MM-DD",
  "UK Format (DD/MM/YYYY)": "DD/MM/YYYY",
  "Short US (MM/DD/YY)": "MM/DD/YY",
  "With Month Name (MMM DD, YYYY)": "MMM DD, YYYY",
  "Long Date (D MMMM YYYY)": "D MMMM YYYY"
};
var DateSelectorPlugin = class extends import_obsidian.Plugin {
  async onload() {
    console.log("Loading Date Selector Plugin");
    await this.loadSettings();
    this.addSettingTab(new DateSelectorSettingTab(this.app, this));
    const dateSuggester = new DateSuggester(this.app, this);
    this.registerEditorSuggest(dateSuggester);
    
    // Add a keydown event listener to check for triggers on every keypress
    this.registerDomEvent(document, "keydown", (evt) => {
      // Check if @ key is pressed (key code 50 with shift or the @ key directly)
      const isAtSymbol = (evt.key === '@') || (evt.keyCode === 50 && evt.shiftKey);
      
      // For @ symbol, add a small delay to ensure the character is in the editor
      if (isAtSymbol) {
        console.log("@ key detected in keydown!");
        setTimeout(() => {
          dateSuggester.checkForTrigger();
        }, 10);
      } else {
        // For other keys, check immediately
        dateSuggester.checkForTrigger();
      }
    });
    
    // Add keyup handler to catch @ symbols that might be missed by keydown
    this.registerDomEvent(document, "keyup", (evt) => {
      const isAtSymbol = (evt.key === '@') || (evt.keyCode === 50 && evt.shiftKey);
      if (isAtSymbol) {
        console.log("@ key detected in keyup!");
        dateSuggester.checkForTrigger();
      }
    });
    
    // Monitor for input events (catches paste and other input methods)
    this.registerDomEvent(document, "input", (evt) => {
      const target = evt.target;
      // Check if the input is in an editor
      if (target && target.classList && target.classList.contains("cm-content")) {
        console.log("Input event detected in editor");
        // Small delay to ensure content is updated
        setTimeout(() => {
          dateSuggester.checkForTrigger();
        }, 10);
      }
    });
    
    this.addCommand({
      id: "insert-update-date-command",
      name: "Insert or Update Date (Command)",
      editorCallback: (editor, ctx) => {
        const selectedText = editor.getSelection();
        this.openDateModal(editor, selectedText || null, editor.getCursor(), editor.getCursor());
      }
    });
    this.registerDomEvent(document, "click", (evt) => {
      console.log("Click event detected");
      const target = evt.target;
      const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      if (!view || !target) {
        console.log("No view or target found", { hasView: !!view, hasTarget: !!target });
        return;
      }
      const isEditorClick = target.closest(".cm-editor") !== null;
      console.log("Is editor click:", isEditorClick, "Target:", target.tagName, target.className);
      if (isEditorClick) {
        const editor = view.editor;
        console.log("Got editor instance");
        try {
          const clickedText = target.textContent || "";
          console.log("Clicked element text:", clickedText);
          if (!clickedText.trim()) {
            console.log("No text content in clicked element");
            return;
          }
          const cursor = editor.getCursor();
          const pos = editor.posToOffset(cursor);
          if (pos === null) {
            console.log("Could not get position offset");
            return;
          }
          const linePos = editor.offsetToPos(pos);
          const line = editor.getLine(linePos.line);
          
          // Find the date in the clicked text first
          const { foundDate, start, end } = this.findDateAtPosition(line, cursor.ch);
          console.log('Date search in clicked element:', { foundDate, start, end });

          if (foundDate && clickedText.includes(foundDate)) {
            console.log("Found date in clicked element, opening modal");
            evt.preventDefault();
            evt.stopPropagation();
            const dateStart = line.indexOf(foundDate);
            if (dateStart >= 0) {
              this.openDateModal(
                editor,
                foundDate,
                { line: linePos.line, ch: dateStart },
                { line: linePos.line, ch: dateStart + foundDate.length }
              );
            }
          }
        } catch (error) {
          console.error("Error in click handler:", error);
        }
      }
    });
    console.log("Date Selector Plugin Loaded");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    console.log("Loaded settings:", this.settings);
  }
  async saveSettings() {
    await this.saveData(this.settings);
    console.log("Saved settings:", this.settings);
  }
  // Helper function to open the modal
  openDateModal(editor, currentDateString, replaceStart, replaceEnd) {
    new DateSelectorModal(this.app, currentDateString, this.settings.outputFormat, (newDate) => {
      editor.replaceRange(newDate, replaceStart, replaceEnd);
    }).open();
  }
  // Helper function to find a date at a given position in text
  findDateAtPosition(line, ch) {
    console.log("Finding date in line:", line, "at position:", ch);
    
    // Match common date formats - order matters, more specific first
    const dateFormats = [
        /\b\d{4}-\d{2}-\d{2}\b/, // YYYY-MM-DD
        /\b\d{2}[-/]\d{2}[-/]\d{4}\b/, // MM-DD-YYYY or MM/DD/YYYY
        /\b\d{2}[-/]\d{2}[-/]\d{2}\b/, // MM-DD-YY or MM/DD/YY
        /\b\d{1,2}\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[a-z]*\s\d{4}\b/i, // 1 Jan 2024
        /\b(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[a-z]*\s\d{1,2},?\s\d{4}\b/i, // Jan 1, 2024
        /\b\d{2}\.\d{2}\.\d{4}\b/ // DD.MM.YYYY or MM.DD.YYYY
    ];

    for (const format of dateFormats) {
        const matches = Array.from(line.matchAll(new RegExp(format, 'g')));
        
        for (const match of matches) {
            const start = match.index;
            const end = start + match[0].length;
            console.log('Found match:', { match: match[0], start, end, cursorAt: ch });
            
            // Only return a match if the cursor is between characters (not at the edges)
            if (ch > start && ch < end) {
                console.log('Cursor is within match (not at edges)');
                return { foundDate: match[0], start, end };
            }
        }
    }
    
    console.log('No date found at cursor position');
    return { foundDate: null, start: -1, end: -1 };
  }
};
var DateSuggester = class extends import_obsidian.EditorSuggest {
  plugin;
  isSuggesting = false;

  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
    // Match the @ character
    this.char = '@';
  }

  // Manual trigger method that can be called on every keypress
  checkForTrigger() {
    const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (view && view.editor) {
      const cursor = view.editor.getCursor();
      const result = this.onTrigger(cursor, view.editor, view.file);
      
      if (result) {
        this.isSuggesting = true;
        this.trigger(view.editor, view.file, true);
      } else if (this.isSuggesting) {
        this.isSuggesting = false;
        this.close();
      }
    }
  }

  // This tells Obsidian when to trigger the suggestions
  onTrigger(cursor, editor, file) {
    const currentLine = editor.getLine(cursor.line);
    const currentPos = cursor.ch;

    console.log('onTrigger called with:', {
      currentLine,
      cursorPosition: currentPos,
      cursorLine: cursor.line,
      charAtCursor: currentLine[currentPos],
      charBeforeCursor: currentPos > 0 ? currentLine[currentPos - 1] : null,
      fullLineLength: currentLine.length
    });

    // Special case: If we just typed @, check if it's at the cursor position - 1
    if (currentPos > 0 && currentLine[currentPos - 1] === '@') {
      console.log('@ symbol found at cursor-1 position');
      return {
        start: { line: cursor.line, ch: currentPos - 1 },
        end: { line: cursor.line, ch: currentPos },
        query: ''
      };
    }

    // Get text before cursor
    const beforeCursor = currentLine.substring(0, currentPos);
    
    // Find the last @ before cursor position
    const lastAtPos = beforeCursor.lastIndexOf(this.char);
    
    console.log('@ symbol check:', {
      beforeCursor,
      lastAtPos,
      hasAtSymbol: lastAtPos >= 0,
      textAfterAt: lastAtPos >= 0 ? beforeCursor.substring(lastAtPos + 1) : ''
    });

    // If we find an @ before the cursor, trigger
    if (lastAtPos >= 0) {
      // Get the text between @ and cursor for the query
      const query = beforeCursor.substring(lastAtPos + 1);
      
      // Check if there's a space immediately after the @ symbol - dismiss if so
      if (query.startsWith(' ')) {
        console.log('Space after @ found, dismissing suggestion');
        return null;
      }
      
      console.log('Triggering suggestion with query:', query);
      
      return {
        start: { line: cursor.line, ch: lastAtPos },
        end: { line: cursor.line, ch: currentPos },
        query: query
      };
    }

    console.log('Not triggering suggestion');
    return null;
  }

  getSuggestions(context) {
    console.log('Getting suggestions with context:', context);
    // Return a date picker suggestion
    return [{ label: "Pick a date..." }];
  }

  renderSuggestion(suggestion, el) {
    el.setText(suggestion.label);
  }

  selectSuggestion(suggestion, evt) {
    if (!this.context) {
      console.error("Editor context not available in selectSuggestion");
      return;
    }

    const editor = this.context.editor;
    const startPos = this.context.start;
    const endPos = this.context.end;
    
    if (!editor || !startPos || !endPos) {
      console.error("Missing editor context components");
      return;
    }
    
    this.close();
    this.plugin.openDateModal(editor, null, startPos, endPos);
  }
};
var DateSelectorSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Date Selector Settings" });
    new import_obsidian.Setting(containerEl).setName("Date Format").setDesc("Choose the format for dates when inserting or updating").addDropdown((dropdown) => {
      Object.entries(DATE_FORMATS).forEach(([name, format]) => {
        dropdown.addOption(format, name);
      });
      dropdown.setValue(this.plugin.settings.outputFormat).onChange(async (value) => {
        this.plugin.settings.outputFormat = value;
        await this.plugin.saveSettings();
      });
    });
  }
};
var DateSelectorModal = class extends import_obsidian.Modal {
  constructor(app, currentDateString, outputFormat, onSubmit) {
    super(app);
    this.currentDateString = currentDateString;
    this.onSubmit = onSubmit;
    this.outputFormat = outputFormat;
    try {
      const formats = [
        "YYYY-MM-DD",
        "MM-DD-YYYY",
        "MM/DD/YYYY",
        "DD/MM/YYYY",
        "DD.MM.YYYY",
        "MMM DD YYYY",
        "MMM DD, YYYY",
        "D MMM YYYY",
        "MM-DD-YY",
        "MM/DD/YY"
      ];
      if (this.currentDateString) {
        const parsedDate = (0, import_obsidian.moment)(this.currentDateString, formats, true);
        if (parsedDate.isValid()) {
          this.selectedDate = parsedDate.format("YYYY-MM-DD");
        } else {
          this.selectedDate = (0, import_obsidian.moment)().format("YYYY-MM-DD");
        }
      } else {
        this.selectedDate = (0, import_obsidian.moment)().format("YYYY-MM-DD");
      }
    } catch (e) {
      console.error("Error parsing date:", e);
      this.selectedDate = (0, import_obsidian.moment)().format("YYYY-MM-DD");
    }
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass('date-selector-modal');
    contentEl.createEl('h2', { text: 'Select a Date' });

    const dateInput = contentEl.createEl('input', { 
        type: 'date', 
        cls: 'date-selector-input'
    });
    dateInput.value = this.selectedDate;

    dateInput.addEventListener('change', (evt) => {
        this.selectedDate = evt.target.value;
    });

    contentEl.createEl('div', { cls: 'date-selector-spacing' });

    new import_obsidian.Setting(contentEl)
        .addButton((btn) =>
            btn
                .setButtonText('Confirm Date')
                .setCta()
                .onClick(() => {
                    if (!this.selectedDate) {
                        console.error("No date selected");
                        return;
                    }
                    this.close();
                    const formattedDate = (0, import_obsidian.moment)(this.selectedDate).format(this.outputFormat);
                    this.onSubmit(formattedDate);
                }));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsic3JjL21haW4udHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbImltcG9ydCB7XG4gICAgQXBwLFxuICAgIEVkaXRvcixcbiAgICBFZGl0b3JQb3NpdGlvbixcbiAgICBFZGl0b3JTdWdnZXN0LFxuICAgIEVkaXRvclN1Z2dlc3RDb250ZXh0LFxuICAgIEVkaXRvclN1Z2dlc3RUcmlnZ2VySW5mbyxcbiAgICBNYXJrZG93blZpZXcsXG4gICAgTWFya2Rvd25GaWxlSW5mbyxcbiAgICBNb2RhbCxcbiAgICBQbHVnaW4sXG4gICAgUGx1Z2luU2V0dGluZ1RhYixcbiAgICBTZXR0aW5nLFxuICAgIFRGaWxlLFxuICAgIG1vbWVudFxufSBmcm9tICdvYnNpZGlhbic7XG5cbmludGVyZmFjZSBEYXRlU2VsZWN0b3JTZXR0aW5ncyB7XG4gICAgb3V0cHV0Rm9ybWF0OiBzdHJpbmc7XG59XG5cbmNvbnN0IERFRkFVTFRfU0VUVElOR1M6IERhdGVTZWxlY3RvclNldHRpbmdzID0ge1xuICAgIG91dHB1dEZvcm1hdDogJ01NL0REL1lZWVknIC8vIERlZmF1bHQgdG8gVVMgZm9ybWF0XG59O1xuXG5jb25zdCBEQVRFX0ZPUk1BVFMgPSB7XG4gICAgJ1VTIEZvcm1hdCAoTU0vREQvWVlZWSknOiAnTU0vREQvWVlZWScsXG4gICAgJ0ludGVybmF0aW9uYWwgKFlZWVktTU0tREQpJzogJ1lZWVktTU0tREQnLFxuICAgICdVSyBGb3JtYXQgKEREL01NL1lZWVkpJzogJ0REL01NL1lZWVknLFxuICAgICdTaG9ydCBVUyAoTU0vREQvWVkpJzogJ01NL0REL1lZJyxcbiAgICAnV2l0aCBNb250aCBOYW1lIChNTU0gREQsIFlZWVkpJzogJ01NTSBERCwgWVlZWScsXG4gICAgJ0xvbmcgRGF0ZSAoRCBNTU1NIFlZWVkpJzogJ0QgTU1NTSBZWVlZJ1xufTtcblxuLy8gSW50ZXJmYWNlIGZvciBvdXIgc3VnZ2VzdGlvbiBpdGVtXG5pbnRlcmZhY2UgRGF0ZVN1Z2dlc3Rpb24ge1xuICAgIGxhYmVsOiBzdHJpbmc7XG59XG5cbi8vIFRoZSBtYWluIHBsdWdpbiBjbGFzc1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGF0ZVNlbGVjdG9yUGx1Z2luIGV4dGVuZHMgUGx1Z2luIHtcbiAgICBzZXR0aW5nczogRGF0ZVNlbGVjdG9yU2V0dGluZ3M7XG5cbiAgICBhc3luYyBvbmxvYWQoKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdMb2FkaW5nIERhdGUgU2VsZWN0b3IgUGx1Z2luJyk7XG4gICAgICAgIFxuICAgICAgICAvLyBMb2FkIHNldHRpbmdzIGZpcnN0XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZFNldHRpbmdzKCk7XG5cbiAgICAgICAgLy8gQWRkIHRoZSBzZXR0aW5ncyB0YWJcbiAgICAgICAgdGhpcy5hZGRTZXR0aW5nVGFiKG5ldyBEYXRlU2VsZWN0b3JTZXR0aW5nVGFiKHRoaXMuYXBwLCB0aGlzKSk7XG5cbiAgICAgICAgLy8gUmVnaXN0ZXIgdGhlIEVkaXRvclN1Z2dlc3QgY29tcG9uZW50IGZvciBAIHRyaWdnZXJcbiAgICAgICAgdGhpcy5yZWdpc3RlckVkaXRvclN1Z2dlc3QobmV3IERhdGVTdWdnZXN0ZXIodGhpcy5hcHAsIHRoaXMpKTtcblxuICAgICAgICAvLyBDb21tYW5kIGZvciBNYW51YWwgVHJpZ2dlclxuICAgICAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgICAgICAgaWQ6ICdpbnNlcnQtdXBkYXRlLWRhdGUtY29tbWFuZCcsXG4gICAgICAgICAgICBuYW1lOiAnSW5zZXJ0IG9yIFVwZGF0ZSBEYXRlIChDb21tYW5kKScsXG4gICAgICAgICAgICBlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCBjdHg6IE1hcmtkb3duVmlldyB8IE1hcmtkb3duRmlsZUluZm8pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RlZFRleHQgPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuRGF0ZU1vZGFsKGVkaXRvciwgc2VsZWN0ZWRUZXh0IHx8IG51bGwsIGVkaXRvci5nZXRDdXJzb3IoKSwgZWRpdG9yLmdldEN1cnNvcigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUmVnaXN0ZXIgY2xpY2sgaGFuZGxlciBmb3IgZGF0ZXMgaW4gdGhlIGRvY3VtZW50XG4gICAgICAgIHRoaXMucmVnaXN0ZXJEb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJywgKGV2dDogTW91c2VFdmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0NsaWNrIGV2ZW50IGRldGVjdGVkJyk7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBldnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50O1xuICAgICAgICAgICAgY29uc3QgdmlldyA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVWaWV3T2ZUeXBlKE1hcmtkb3duVmlldyk7XG5cbiAgICAgICAgICAgIGlmICghdmlldyB8fCAhdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ05vIHZpZXcgb3IgdGFyZ2V0IGZvdW5kJywgeyBoYXNWaWV3OiAhIXZpZXcsIGhhc1RhcmdldDogISF0YXJnZXQgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBpc0VkaXRvckNsaWNrID0gdGFyZ2V0LmNsb3Nlc3QoJy5jbS1lZGl0b3InKSAhPT0gbnVsbDtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdJcyBlZGl0b3IgY2xpY2s6JywgaXNFZGl0b3JDbGljaywgJ1RhcmdldDonLCB0YXJnZXQudGFnTmFtZSwgdGFyZ2V0LmNsYXNzTmFtZSk7XG5cbiAgICAgICAgICAgIGlmIChpc0VkaXRvckNsaWNrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZWRpdG9yID0gdmlldy5lZGl0b3I7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0dvdCBlZGl0b3IgaW5zdGFuY2UnKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGNsaWNrZWQgZWxlbWVudCdzIHRleHQgY29udGVudFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjbGlja2VkVGV4dCA9IHRhcmdldC50ZXh0Q29udGVudCB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0NsaWNrZWQgZWxlbWVudCB0ZXh0OicsIGNsaWNrZWRUZXh0KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBkaWRuJ3QgY2xpY2sgZGlyZWN0bHkgb24gdGV4dCwgZG9uJ3QgcHJvY2VlZFxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNsaWNrZWRUZXh0LnRyaW0oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ05vIHRleHQgY29udGVudCBpbiBjbGlja2VkIGVsZW1lbnQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgcG9zaXRpb24gZnJvbSB0aGUgZWRpdG9yJ3MgY29vcmRpbmF0ZSBzeXN0ZW1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvcigpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb3MgPSBlZGl0b3IucG9zVG9PZmZzZXQoY3Vyc29yKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0NvdWxkIG5vdCBnZXQgcG9zaXRpb24gb2Zmc2V0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW5lUG9zID0gZWRpdG9yLm9mZnNldFRvUG9zKHBvcyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBlZGl0b3IuZ2V0TGluZShsaW5lUG9zLmxpbmUpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgZGF0ZSBpbiB0aGUgY2xpY2tlZCB0ZXh0IGZpcnN0XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZm91bmREYXRlLCBzdGFydCwgZW5kIH0gPSB0aGlzLmZpbmREYXRlQXRQb3NpdGlvbihjbGlja2VkVGV4dCwgY2xpY2tlZFRleHQubGVuZ3RoLzIpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnRGF0ZSBzZWFyY2ggaW4gY2xpY2tlZCBlbGVtZW50OicsIHsgZm91bmREYXRlLCBzdGFydCwgZW5kIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZERhdGUgJiYgY2xpY2tlZFRleHQuaW5jbHVkZXMoZm91bmREYXRlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZvdW5kIGRhdGUgaW4gY2xpY2tlZCBlbGVtZW50LCBvcGVuaW5nIG1vZGFsJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmluZCB3aGVyZSB0aGlzIGRhdGUgaXMgaW4gdGhlIGFjdHVhbCBsaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRlU3RhcnQgPSBsaW5lLmluZGV4T2YoZm91bmREYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRlU3RhcnQgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3BlbkRhdGVNb2RhbChlZGl0b3IsIGZvdW5kRGF0ZSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgbGluZTogbGluZVBvcy5saW5lLCBjaDogZGF0ZVN0YXJ0IH0sIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGxpbmU6IGxpbmVQb3MubGluZSwgY2g6IGRhdGVTdGFydCArIGZvdW5kRGF0ZS5sZW5ndGggfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBjbGljayBoYW5kbGVyOicsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKCdEYXRlIFNlbGVjdG9yIFBsdWdpbiBMb2FkZWQnKTtcbiAgICB9XG5cbiAgICBhc3luYyBsb2FkU2V0dGluZ3MoKSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFVFRJTkdTLCBhd2FpdCB0aGlzLmxvYWREYXRhKCkpO1xuICAgICAgICBjb25zb2xlLmxvZygnTG9hZGVkIHNldHRpbmdzOicsIHRoaXMuc2V0dGluZ3MpO1xuICAgIH1cblxuICAgIGFzeW5jIHNhdmVTZXR0aW5ncygpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zYXZlRGF0YSh0aGlzLnNldHRpbmdzKTtcbiAgICAgICAgY29uc29sZS5sb2coJ1NhdmVkIHNldHRpbmdzOicsIHRoaXMuc2V0dGluZ3MpO1xuICAgIH1cbn1cblxuLy8gVGhlIE1vZGFsIGZvciBzZWxlY3RpbmcgZGF0ZXNcbmNsYXNzIERhdGVTZWxlY3Rvck1vZGFsIGV4dGVuZHMgTW9kYWwge1xuICAgIGN1cnJlbnREYXRlU3RyaW5nOiBzdHJpbmcgfCBudWxsO1xuICAgIG9uU3VibWl0OiAocmVzdWx0OiBzdHJpbmcpID0+IHZvaWQ7XG4gICAgc2VsZWN0ZWREYXRlOiBzdHJpbmc7XG4gICAgb3V0cHV0Rm9ybWF0OiBzdHJpbmc7XG5cbiAgICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgY3VycmVudERhdGVTdHJpbmc6IHN0cmluZyB8IG51bGwsIG91dHB1dEZvcm1hdDogc3RyaW5nLCBvblN1Ym1pdDogKHJlc3VsdDogc3RyaW5nKSA9PiB2b2lkKSB7XG4gICAgICAgIHN1cGVyKGFwcCk7XG4gICAgICAgIHRoaXMuY3VycmVudERhdGVTdHJpbmcgPSBjdXJyZW50RGF0ZVN0cmluZztcbiAgICAgICAgdGhpcy5vblN1Ym1pdCA9IG9uU3VibWl0O1xuICAgICAgICB0aGlzLm91dHB1dEZvcm1hdCA9IG91dHB1dEZvcm1hdDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gVHJ5IHRvIHBhcnNlIHRoZSBkYXRlIHdpdGggbXVsdGlwbGUgZm9ybWF0c1xuICAgICAgICAgICAgY29uc3QgZm9ybWF0cyA9IFtcbiAgICAgICAgICAgICAgICAnWVlZWS1NTS1ERCcsXG4gICAgICAgICAgICAgICAgJ01NLURELVlZWVknLFxuICAgICAgICAgICAgICAgICdNTS9ERC9ZWVlZJyxcbiAgICAgICAgICAgICAgICAnREQvTU0vWVlZWScsXG4gICAgICAgICAgICAgICAgJ0RELk1NLllZWVknLFxuICAgICAgICAgICAgICAgICdNTU0gREQgWVlZWScsXG4gICAgICAgICAgICAgICAgJ01NTSBERCwgWVlZWScsXG4gICAgICAgICAgICAgICAgJ0QgTU1NIFlZWVknLFxuICAgICAgICAgICAgICAgICdNTS1ERC1ZWScsXG4gICAgICAgICAgICAgICAgJ01NL0REL1lZJ1xuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudERhdGVTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBUcnkgdG8gcGFyc2Ugd2l0aCBtb21lbnQgdXNpbmcgbXVsdGlwbGUgZm9ybWF0c1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZERhdGUgPSBtb21lbnQodGhpcy5jdXJyZW50RGF0ZVN0cmluZywgZm9ybWF0cywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZERhdGUuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN0b3JlIGludGVybmFsbHkgYXMgWVlZWS1NTS1ERCBmb3IgdGhlIGlucHV0IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZERhdGUgPSBwYXJzZWREYXRlLmZvcm1hdCgnWVlZWS1NTS1ERCcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWREYXRlID0gbW9tZW50KCkuZm9ybWF0KCdZWVlZLU1NLUREJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkRGF0ZSA9IG1vbWVudCgpLmZvcm1hdCgnWVlZWS1NTS1ERCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBwYXJzaW5nIGRhdGU6JywgZSk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkRGF0ZSA9IG1vbWVudCgpLmZvcm1hdCgnWVlZWS1NTS1ERCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25PcGVuKCkge1xuICAgICAgICBjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcbiAgICAgICAgY29udGVudEVsLmVtcHR5KCk7XG4gICAgICAgIGNvbnRlbnRFbC5hZGRDbGFzcygnZGF0ZS1zZWxlY3Rvci1tb2RhbCcpO1xuICAgICAgICBjb250ZW50RWwuY3JlYXRlRWwoJ2gyJywgeyB0ZXh0OiAnU2VsZWN0IGEgRGF0ZScgfSk7XG5cbiAgICAgICAgY29uc29sZS5sb2coJ0NyZWF0aW5nIGRhdGUgaW5wdXQuLi4nKTtcbiAgICAgICAgY29uc3QgZGF0ZUlucHV0ID0gY29udGVudEVsLmNyZWF0ZUVsKCdpbnB1dCcsIHsgXG4gICAgICAgICAgICB0eXBlOiAnZGF0ZScsIFxuICAgICAgICAgICAgY2xzOiAnZGF0ZS1zZWxlY3Rvci1pbnB1dCdcbiAgICAgICAgfSk7XG4gICAgICAgIGRhdGVJbnB1dC52YWx1ZSA9IHRoaXMuc2VsZWN0ZWREYXRlO1xuICAgICAgICBjb25zb2xlLmxvZygnRGF0ZSBpbnB1dCBjcmVhdGVkOicsIGRhdGVJbnB1dCk7XG5cbiAgICAgICAgZGF0ZUlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIChldnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWREYXRlID0gKGV2dC50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudCkudmFsdWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnRlbnRFbC5jcmVhdGVFbCgnZGl2JywgeyBjbHM6ICdkYXRlLXNlbGVjdG9yLXNwYWNpbmcnIH0pO1xuXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRlbnRFbClcbiAgICAgICAgICAgIC5hZGRCdXR0b24oKGJ0bikgPT5cbiAgICAgICAgICAgICAgICBidG5cbiAgICAgICAgICAgICAgICAgICAgLnNldEJ1dHRvblRleHQoJ0NvbmZpcm0gRGF0ZScpXG4gICAgICAgICAgICAgICAgICAgIC5zZXRDdGEoKVxuICAgICAgICAgICAgICAgICAgICAub25DbGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc2VsZWN0ZWREYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIk5vIGRhdGUgc2VsZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBzZWxlY3RlZCBmb3JtYXQgZnJvbSBzZXR0aW5nc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZm9ybWF0dGVkRGF0ZSA9IG1vbWVudCh0aGlzLnNlbGVjdGVkRGF0ZSkuZm9ybWF0KHRoaXMub3V0cHV0Rm9ybWF0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25TdWJtaXQoZm9ybWF0dGVkRGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAvLyBGb2N1cyBhbmQgb3BlbiBkYXRlIHBpY2tlciB3aXRoIG11bHRpcGxlIGF0dGVtcHRzXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0luaXRpYWwgdGltZW91dCBmaXJlZCcpO1xuICAgICAgICAgICAgZGF0ZUlucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnSW5wdXQgZm9jdXNlZCcpO1xuXG4gICAgICAgICAgICAvLyBUcnkgbXVsdGlwbGUgc2VsZWN0b3JzIHRvIGZpbmQgdGhlIGNhbGVuZGFyIGJ1dHRvblxuICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3JzID0gW1xuICAgICAgICAgICAgICAgICdbdGl0bGU9XCJzaG93IGRhdGUgcGlja2VyXCJdJyxcbiAgICAgICAgICAgICAgICAnaW5wdXRbdHlwZT1cImRhdGVcIl06Oi13ZWJraXQtY2FsZW5kYXItcGlja2VyLWluZGljYXRvcicsXG4gICAgICAgICAgICAgICAgJy5jYWxlbmRhci1idXR0b24nLFxuICAgICAgICAgICAgICAgICdidXR0b24uZGF0ZS1waWNrZXItYnV0dG9uJ1xuICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1RyeWluZyB0byBmaW5kIGNhbGVuZGFyIGJ1dHRvbi4uLicpO1xuICAgICAgICAgICAgbGV0IGNhbGVuZGFyQnV0dG9uID0gbnVsbDtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBzZWxlY3RvciBvZiBzZWxlY3RvcnMpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVHJ5aW5nIHNlbGVjdG9yOicsIHNlbGVjdG9yKTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZGF0ZUlucHV0LnBhcmVudEVsZW1lbnQ/LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGb3VuZCBidXR0b24gd2l0aCBzZWxlY3RvcjonLCBzZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgIGNhbGVuZGFyQnV0dG9uID0gZWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY2FsZW5kYXJCdXR0b24pIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQ2FsZW5kYXIgYnV0dG9uIGZvdW5kLCBhdHRlbXB0aW5nIHRvIGNsaWNrJyk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgKGNhbGVuZGFyQnV0dG9uIGFzIEhUTUxFbGVtZW50KS5jbGljaygpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQ2xpY2sgYXR0ZW1wdGVkJyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjbGlja2luZyBjYWxlbmRhciBidXR0b246JywgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnTm8gY2FsZW5kYXIgYnV0dG9uIGZvdW5kIHdpdGggYW55IHNlbGVjdG9yJyk7XG4gICAgICAgICAgICAgICAgLy8gVHJ5IGFsdGVybmF0aXZlIGFwcHJvYWNoIC0gc2ltdWxhdGUga2V5Ym9hcmQgZXZlbnRcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVHJ5aW5nIGtleWJvYXJkIGV2ZW50Li4uJyk7XG4gICAgICAgICAgICAgICAgZGF0ZUlucHV0LmRpc3BhdGNoRXZlbnQobmV3IEtleWJvYXJkRXZlbnQoJ2tleWRvd24nLCB7IFxuICAgICAgICAgICAgICAgICAgICBrZXk6ICdBcnJvd0Rvd24nLFxuICAgICAgICAgICAgICAgICAgICBjb2RlOiAnQXJyb3dEb3duJyxcbiAgICAgICAgICAgICAgICAgICAga2V5Q29kZTogNDAsXG4gICAgICAgICAgICAgICAgICAgIHdoaWNoOiA0MCxcbiAgICAgICAgICAgICAgICAgICAgYWx0S2V5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBidWJibGVzOiB0cnVlXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAyMDApOyAvLyBJbmNyZWFzZWQgdGltZW91dFxuICAgIH1cblxuICAgIG9uQ2xvc2UoKSB7XG4gICAgICAgIGNvbnN0IHsgY29udGVudEVsIH0gPSB0aGlzO1xuICAgICAgICBjb250ZW50RWwuZW1wdHkoKTtcbiAgICB9XG59XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsc0JBZU87QUFNUCxJQUFNLG1CQUF5QztBQUFBLEVBQzNDLGNBQWM7QUFBQTtBQUNsQjtBQUVBLElBQU0sZUFBZTtBQUFBLEVBQ2pCLDBCQUEwQjtBQUFBLEVBQzFCLDhCQUE4QjtBQUFBLEVBQzlCLDBCQUEwQjtBQUFBLEVBQzFCLHVCQUF1QjtBQUFBLEVBQ3ZCLGtDQUFrQztBQUFBLEVBQ2xDLDJCQUEyQjtBQUMvQjtBQVFBLElBQXFCLHFCQUFyQixjQUFnRCx1QkFBTztBQUFBLEVBR25ELE1BQU0sU0FBUztBQUNYLFlBQVEsSUFBSSw4QkFBOEI7QUFHMUMsVUFBTSxLQUFLLGFBQWE7QUFHeEIsU0FBSyxjQUFjLElBQUksdUJBQXVCLEtBQUssS0FBSyxJQUFJLENBQUM7QUFHN0QsU0FBSyxzQkFBc0IsSUFBSSxjQUFjLEtBQUssS0FBSyxJQUFJLENBQUM7QUFHNUQsU0FBSyxXQUFXO0FBQUEsTUFDWixJQUFJO0FBQUEsTUFDSixNQUFNO0FBQUEsTUFDTixnQkFBZ0IsQ0FBQyxRQUFnQixRQUF5QztBQUN0RSxjQUFNLGVBQWUsT0FBTyxhQUFhO0FBQ3pDLGFBQUssY0FBYyxRQUFRLGdCQUFnQixNQUFNLE9BQU8sVUFBVSxHQUFHLE9BQU8sVUFBVSxDQUFDO0FBQUEsTUFDM0Y7QUFBQSxJQUNKLENBQUM7QUFHRCxTQUFLLGlCQUFpQixVQUFVLFNBQVMsQ0FBQyxRQUFvQjtBQUMxRCxjQUFRLElBQUksc0JBQXNCO0FBQ2xDLFlBQU0sU0FBUyxJQUFJO0FBQ25CLFlBQU0sT0FBTyxLQUFLLElBQUksVUFBVSxvQkFBb0IsNEJBQVk7QUFFaEUsVUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRO0FBQ2xCLGdCQUFRLElBQUksMkJBQTJCLEVBQUUsU0FBUyxDQUFDLENBQUMsTUFBTSxXQUFXLENBQUMsQ0FBQyxPQUFPLENBQUM7QUFDL0U7QUFBQSxNQUNKO0FBRUEsWUFBTSxnQkFBZ0IsT0FBTyxRQUFRLFlBQVksTUFBTTtBQUN2RCxjQUFRLElBQUksb0JBQW9CLGVBQWUsV0FBVyxPQUFPLFNBQVMsT0FBTyxTQUFTO0FBRTFGLFVBQUksZUFBZTtBQUNmLGNBQU0sU0FBUyxLQUFLO0FBQ3BCLGdCQUFRLElBQUkscUJBQXFCO0FBRWpDLFlBQUk7QUFFQSxnQkFBTSxjQUFjLE9BQU8sZUFBZTtBQUMxQyxrQkFBUSxJQUFJLHlCQUF5QixXQUFXO0FBR2hELGNBQUksQ0FBQyxZQUFZLEtBQUssR0FBRztBQUNyQixvQkFBUSxJQUFJLG9DQUFvQztBQUNoRDtBQUFBLFVBQ0o7QUFHQSxnQkFBTSxTQUFTLE9BQU8sVUFBVTtBQUNoQyxnQkFBTSxNQUFNLE9BQU8sWUFBWSxNQUFNO0FBQ3JDLGNBQUksUUFBUSxNQUFNO0FBQ2Qsb0JBQVEsSUFBSSwrQkFBK0I7QUFDM0M7QUFBQSxVQUNKO0FBRUEsZ0JBQU0sVUFBVSxPQUFPLFlBQVksR0FBRztBQUN0QyxnQkFBTSxPQUFPLE9BQU8sUUFBUSxRQUFRLElBQUk7QUFHeEMsZ0JBQU0sRUFBRSxXQUFXLE9BQU8sSUFBSSxJQUFJLEtBQUssbUJBQW1CLGFBQWEsWUFBWSxTQUFPLENBQUM7QUFDM0Ysa0JBQVEsSUFBSSxtQ0FBbUMsRUFBRSxXQUFXLE9BQU8sSUFBSSxDQUFDO0FBRXhFLGNBQUksYUFBYSxZQUFZLFNBQVMsU0FBUyxHQUFHO0FBQzlDLG9CQUFRLElBQUksOENBQThDO0FBQzFELGdCQUFJLGVBQWU7QUFDbkIsZ0JBQUksZ0JBQWdCO0FBR3BCLGtCQUFNLFlBQVksS0FBSyxRQUFRLFNBQVM7QUFDeEMsZ0JBQUksYUFBYSxHQUFHO0FBQ2hCLG1CQUFLO0FBQUEsZ0JBQWM7QUFBQSxnQkFBUTtBQUFBLGdCQUN2QixFQUFFLE1BQU0sUUFBUSxNQUFNLElBQUksVUFBVTtBQUFBLGdCQUNwQyxFQUFFLE1BQU0sUUFBUSxNQUFNLElBQUksWUFBWSxVQUFVLE9BQU87QUFBQSxjQUMzRDtBQUFBLFlBQ0o7QUFBQSxVQUNKO0FBQUEsUUFDSixTQUFTLE9BQU87QUFDWixrQkFBUSxNQUFNLDJCQUEyQixLQUFLO0FBQUEsUUFDbEQ7QUFBQSxNQUNKO0FBQUEsSUFDSixDQUFDO0FBRUQsWUFBUSxJQUFJLDZCQUE2QjtBQUFBLEVBQzdDO0FBQUEsRUFFQSxNQUFNLGVBQWU7QUFDakIsU0FBSyxXQUFXLE9BQU8sT0FBTyxDQUFDLEdBQUcsa0JBQWtCLE1BQU0sS0FBSyxTQUFTLENBQUM7QUFDekUsWUFBUSxJQUFJLG9CQUFvQixLQUFLLFFBQVE7QUFBQSxFQUNqRDtBQUFBLEVBRUEsTUFBTSxlQUFlO0FBQ2pCLFVBQU0sS0FBSyxTQUFTLEtBQUssUUFBUTtBQUNqQyxZQUFRLElBQUksbUJBQW1CLEtBQUssUUFBUTtBQUFBLEVBQ2hEO0FBQUE7QUFBQSxFQUdBLGNBQWMsUUFBZ0IsbUJBQWtDLGNBQThCLFlBQTRCO0FBQ3RILFFBQUksa0JBQWtCLEtBQUssS0FBSyxtQkFBbUIsS0FBSyxTQUFTLGNBQWMsQ0FBQyxZQUFZO0FBQ3hGLGFBQU8sYUFBYSxTQUFTLGNBQWMsVUFBVTtBQUFBLElBQ3pELENBQUMsRUFBRSxLQUFLO0FBQUEsRUFDWjtBQUFBO0FBQUEsRUFHQSxtQkFBbUIsTUFBYyxJQUFzRTtBQUNuRyxZQUFRLElBQUkseUJBQXlCLE1BQU0sZ0JBQWdCLEVBQUU7QUFHN0QsVUFBTSxjQUFjO0FBQUEsTUFDaEI7QUFBQTtBQUFBLE1BQ0E7QUFBQTtBQUFBLE1BQ0E7QUFBQTtBQUFBLE1BQ0E7QUFBQTtBQUFBLE1BQ0E7QUFBQTtBQUFBLE1BQ0E7QUFBQTtBQUFBLElBQ0o7QUFFQSxlQUFXLFVBQVUsYUFBYTtBQUM5QixjQUFRLElBQUksa0JBQWtCLE1BQU07QUFDcEMsWUFBTSxVQUFVLE1BQU0sS0FBSyxLQUFLLFNBQVMsSUFBSSxPQUFPLFFBQVEsR0FBRyxDQUFDLENBQUM7QUFFakUsaUJBQVcsU0FBUyxTQUFTO0FBQ3pCLGNBQU0sUUFBUSxNQUFNO0FBQ3BCLGNBQU0sTUFBTSxRQUFRLE1BQU0sQ0FBQyxFQUFFO0FBQzdCLGdCQUFRLElBQUksZ0JBQWdCLEVBQUUsT0FBTyxNQUFNLENBQUMsR0FBRyxPQUFPLEtBQUssVUFBVSxHQUFHLENBQUM7QUFFekUsWUFBSSxNQUFNLFNBQVMsTUFBTSxLQUFLO0FBQzFCLGtCQUFRLElBQUksd0JBQXdCO0FBQ3BDLGlCQUFPLEVBQUUsV0FBVyxNQUFNLENBQUMsR0FBRyxPQUFPLElBQUk7QUFBQSxRQUM3QztBQUFBLE1BQ0o7QUFBQSxJQUNKO0FBRUEsWUFBUSxJQUFJLGtDQUFrQztBQUM5QyxXQUFPLEVBQUUsV0FBVyxNQUFNLE9BQU8sSUFBSSxLQUFLLEdBQUc7QUFBQSxFQUNqRDtBQUNKO0FBR0EsSUFBTSxnQkFBTixjQUE0Qiw4QkFBOEI7QUFBQSxFQUd0RCxZQUFZLEtBQVUsUUFBNEI7QUFDOUMsVUFBTSxHQUFHO0FBQ1QsU0FBSyxTQUFTO0FBQUEsRUFDbEI7QUFBQSxFQUVBLFVBQVUsUUFBd0IsUUFBZ0IsTUFBcUQ7QUFDbkcsVUFBTSxjQUFjLE9BQU8sUUFBUSxPQUFPLElBQUk7QUFDOUMsVUFBTSxhQUFhLE9BQU87QUFHMUIsUUFBSSxZQUFZLGFBQWEsQ0FBQyxNQUFNLEtBQUs7QUFDckMsYUFBTztBQUFBLFFBQ0gsT0FBTyxFQUFFLE1BQU0sT0FBTyxNQUFNLElBQUksYUFBYSxFQUFFO0FBQUEsUUFDL0MsS0FBSyxFQUFFLE1BQU0sT0FBTyxNQUFNLElBQUksV0FBVztBQUFBLFFBQ3pDLE9BQU87QUFBQSxNQUNYO0FBQUEsSUFDSjtBQUdBLFVBQU0sZUFBZSxZQUFZLFVBQVUsR0FBRyxVQUFVO0FBQ3hELFVBQU0sWUFBWSxhQUFhLFlBQVksR0FBRztBQUM5QyxRQUFJLGFBQWEsR0FBRztBQUNoQixhQUFPO0FBQUEsUUFDSCxPQUFPLEVBQUUsTUFBTSxPQUFPLE1BQU0sSUFBSSxVQUFVO0FBQUEsUUFDMUMsS0FBSyxFQUFFLE1BQU0sT0FBTyxNQUFNLElBQUksV0FBVztBQUFBLFFBQ3pDLE9BQU8sYUFBYSxVQUFVLFlBQVksQ0FBQztBQUFBLE1BQy9DO0FBQUEsSUFDSjtBQUVBLFdBQU87QUFBQSxFQUNYO0FBQUEsRUFFQSxlQUFlLFNBQWlEO0FBQzVELFdBQU8sQ0FBQyxFQUFFLE9BQU8saUJBQWlCLENBQUM7QUFBQSxFQUN2QztBQUFBLEVBRUEsaUJBQWlCLFlBQTRCLElBQXVCO0FBQ2hFLE9BQUcsUUFBUSxXQUFXLEtBQUs7QUFBQSxFQUMvQjtBQUFBLEVBRUEsaUJBQWlCLFlBQTRCLEtBQXVDO0FBcE94RjtBQXFPUSxVQUFNLFVBQVMsVUFBSyxZQUFMLG1CQUFjO0FBQzdCLFVBQU0sWUFBVyxVQUFLLFlBQUwsbUJBQWM7QUFDL0IsVUFBTSxVQUFTLFVBQUssWUFBTCxtQkFBYztBQUU3QixRQUFJLENBQUMsVUFBVSxDQUFDLFlBQVksQ0FBQyxRQUFRO0FBQ2pDLGNBQVEsTUFBTSxrREFBa0Q7QUFDaEU7QUFBQSxJQUNKO0FBRUEsU0FBSyxNQUFNO0FBQ1gsU0FBSyxPQUFPLGNBQWMsUUFBUSxNQUFNLFVBQVUsTUFBTTtBQUFBLEVBQzVEO0FBQ0o7QUFHQSxJQUFNLHlCQUFOLGNBQXFDLGlDQUFpQjtBQUFBLEVBR2xELFlBQVksS0FBVSxRQUE0QjtBQUM5QyxVQUFNLEtBQUssTUFBTTtBQUNqQixTQUFLLFNBQVM7QUFBQSxFQUNsQjtBQUFBLEVBRUEsVUFBZ0I7QUFDWixVQUFNLEVBQUUsWUFBWSxJQUFJO0FBQ3hCLGdCQUFZLE1BQU07QUFFbEIsZ0JBQVksU0FBUyxNQUFNLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUU3RCxRQUFJLHdCQUFRLFdBQVcsRUFDbEIsUUFBUSxhQUFhLEVBQ3JCLFFBQVEsd0RBQXdELEVBQ2hFLFlBQVksY0FBWTtBQUVyQixhQUFPLFFBQVEsWUFBWSxFQUFFLFFBQVEsQ0FBQyxDQUFDLE1BQU0sTUFBTSxNQUFNO0FBQ3JELGlCQUFTLFVBQVUsUUFBUSxJQUFJO0FBQUEsTUFDbkMsQ0FBQztBQUVELGVBQ0ssU0FBUyxLQUFLLE9BQU8sU0FBUyxZQUFZLEVBQzFDLFNBQVMsT0FBTyxVQUFVO0FBQ3ZCLGFBQUssT0FBTyxTQUFTLGVBQWU7QUFDcEMsY0FBTSxLQUFLLE9BQU8sYUFBYTtBQUFBLE1BQ25DLENBQUM7QUFBQSxJQUNULENBQUM7QUFBQSxFQUNUO0FBQ0o7QUFHQSxJQUFNLG9CQUFOLGNBQWdDLHNCQUFNO0FBQUEsRUFNbEMsWUFBWSxLQUFVLG1CQUFrQyxjQUFzQixVQUFvQztBQUM5RyxVQUFNLEdBQUc7QUFDVCxTQUFLLG9CQUFvQjtBQUN6QixTQUFLLFdBQVc7QUFDaEIsU0FBSyxlQUFlO0FBRXBCLFFBQUk7QUFFQSxZQUFNLFVBQVU7QUFBQSxRQUNaO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsTUFDSjtBQUVBLFVBQUksS0FBSyxtQkFBbUI7QUFFeEIsY0FBTSxpQkFBYSx3QkFBTyxLQUFLLG1CQUFtQixTQUFTLElBQUk7QUFDL0QsWUFBSSxXQUFXLFFBQVEsR0FBRztBQUV0QixlQUFLLGVBQWUsV0FBVyxPQUFPLFlBQVk7QUFBQSxRQUN0RCxPQUFPO0FBQ0gsZUFBSyxtQkFBZSx3QkFBTyxFQUFFLE9BQU8sWUFBWTtBQUFBLFFBQ3BEO0FBQUEsTUFDSixPQUFPO0FBQ0gsYUFBSyxtQkFBZSx3QkFBTyxFQUFFLE9BQU8sWUFBWTtBQUFBLE1BQ3BEO0FBQUEsSUFDSixTQUFTLEdBQUc7QUFDUixjQUFRLE1BQU0sdUJBQXVCLENBQUM7QUFDdEMsV0FBSyxtQkFBZSx3QkFBTyxFQUFFLE9BQU8sWUFBWTtBQUFBLElBQ3BEO0FBQUEsRUFDSjtBQUFBLEVBRUEsU0FBUztBQUNMLFVBQU0sRUFBRSxVQUFVLElBQUk7QUFDdEIsY0FBVSxNQUFNO0FBQ2hCLGNBQVUsU0FBUyxxQkFBcUI7QUFDeEMsY0FBVSxTQUFTLE1BQU0sRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRWxELFlBQVEsSUFBSSx3QkFBd0I7QUFDcEMsVUFBTSxZQUFZLFVBQVUsU0FBUyxTQUFTO0FBQUEsTUFDMUMsTUFBTTtBQUFBLE1BQ04sS0FBSztBQUFBLElBQ1QsQ0FBQztBQUNELGNBQVUsUUFBUSxLQUFLO0FBQ3ZCLFlBQVEsSUFBSSx1QkFBdUIsU0FBUztBQUU1QyxjQUFVLGlCQUFpQixVQUFVLENBQUMsUUFBUTtBQUMxQyxXQUFLLGVBQWdCLElBQUksT0FBNEI7QUFBQSxJQUN6RCxDQUFDO0FBRUQsY0FBVSxTQUFTLE9BQU8sRUFBRSxLQUFLLHdCQUF3QixDQUFDO0FBRTFELFFBQUksd0JBQVEsU0FBUyxFQUNoQixVQUFVLENBQUMsUUFDUixJQUNLLGNBQWMsY0FBYyxFQUM1QixPQUFPLEVBQ1AsUUFBUSxNQUFNO0FBQ1gsVUFBSSxDQUFDLEtBQUssY0FBYztBQUNwQixnQkFBUSxNQUFNLGtCQUFrQjtBQUNoQztBQUFBLE1BQ0o7QUFDQSxXQUFLLE1BQU07QUFFWCxZQUFNLG9CQUFnQix3QkFBTyxLQUFLLFlBQVksRUFBRSxPQUFPLEtBQUssWUFBWTtBQUN4RSxXQUFLLFNBQVMsYUFBYTtBQUFBLElBQy9CLENBQUMsQ0FBQztBQUdkLGVBQVcsTUFBTTtBQXhXekI7QUF5V1ksY0FBUSxJQUFJLHVCQUF1QjtBQUNuQyxnQkFBVSxNQUFNO0FBQ2hCLGNBQVEsSUFBSSxlQUFlO0FBRzNCLFlBQU0sWUFBWTtBQUFBLFFBQ2Q7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxNQUNKO0FBRUEsY0FBUSxJQUFJLG1DQUFtQztBQUMvQyxVQUFJLGlCQUFpQjtBQUVyQixpQkFBVyxZQUFZLFdBQVc7QUFDOUIsZ0JBQVEsSUFBSSxvQkFBb0IsUUFBUTtBQUN4QyxjQUFNLFdBQVUsZUFBVSxrQkFBVixtQkFBeUIsY0FBYztBQUN2RCxZQUFJLFNBQVM7QUFDVCxrQkFBUSxJQUFJLCtCQUErQixRQUFRO0FBQ25ELDJCQUFpQjtBQUNqQjtBQUFBLFFBQ0o7QUFBQSxNQUNKO0FBRUEsVUFBSSxnQkFBZ0I7QUFDaEIsZ0JBQVEsSUFBSSw0Q0FBNEM7QUFDeEQsWUFBSTtBQUNBLFVBQUMsZUFBK0IsTUFBTTtBQUN0QyxrQkFBUSxJQUFJLGlCQUFpQjtBQUFBLFFBQ2pDLFNBQVMsR0FBRztBQUNSLGtCQUFRLE1BQU0sbUNBQW1DLENBQUM7QUFBQSxRQUN0RDtBQUFBLE1BQ0osT0FBTztBQUNILGdCQUFRLElBQUksNENBQTRDO0FBRXhELGdCQUFRLElBQUksMEJBQTBCO0FBQ3RDLGtCQUFVLGNBQWMsSUFBSSxjQUFjLFdBQVc7QUFBQSxVQUNqRCxLQUFLO0FBQUEsVUFDTCxNQUFNO0FBQUEsVUFDTixTQUFTO0FBQUEsVUFDVCxPQUFPO0FBQUEsVUFDUCxRQUFRO0FBQUEsVUFDUixTQUFTO0FBQUEsUUFDYixDQUFDLENBQUM7QUFBQSxNQUNOO0FBQUEsSUFDSixHQUFHLEdBQUc7QUFBQSxFQUNWO0FBQUEsRUFFQSxVQUFVO0FBQ04sVUFBTSxFQUFFLFVBQVUsSUFBSTtBQUN0QixjQUFVLE1BQU07QUFBQSxFQUNwQjtBQUNKOyIsCiAgIm5hbWVzIjogW10KfQo=
