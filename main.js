/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => DateSelectorPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  dateFormat: "MM/DD/YY",
  enableClickDates: true,
  enableAtSuggest: true,
  debugLogging: false
};
var DateSelectorPlugin = class extends import_obsidian.Plugin {
  debugLog(...args) {
    var _a;
    if ((_a = this.settings) == null ? void 0 : _a.debugLogging) {
      console.log("[DateSelector]", ...args);
    }
  }
  async onload() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    this.addSettingTab(new DateSelectorSettingTab(this.app, this));
    this.debugLog("Loading Date Selector Plugin (@ Trigger)");
    if (this.settings.enableAtSuggest) {
      this.registerEditorSuggest(new DateSuggester(this.app, this));
    }
    if (this.settings.enableClickDates) {
      this.registerDomEvent(document, "click", this.handleClickEvent.bind(this), { capture: true });
      this.debugLog("Click listener registered");
    }
    this.debugLog("Date Selector Plugin (@ Trigger) Loaded");
  }
  onunload() {
    this.debugLog("Unloading Date Selector Plugin (@ Trigger)");
  }
  // Helper function to open the modal, used by suggester and command
  openDateModal(editor, initialDateYYYYMMDD, replaceStart, replaceEnd) {
    new DateSelectorModal(this.app, initialDateYYYYMMDD, (newDateYYYYMMDD) => {
      let formattedDate = (0, import_obsidian.moment)(newDateYYYYMMDD, "YYYY-MM-DD").format(this.settings.dateFormat);
      if (!/^\*.*\*$/.test(formattedDate)) {
        formattedDate = `*${formattedDate}*`;
      }
      editor.replaceRange(formattedDate + " ", replaceStart, replaceEnd);
    }).open();
  }
  async handleClickEvent(evt) {
    const target = evt.target;
    const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!view || !target) return;
    const isEditorClick = target.closest(".cm-editor") !== null;
    if (isEditorClick) {
      const editor = view.editor;
      const cmEditor = editor.cm;
      if (!cmEditor) {
        console.error("Date Selector Plugin: Could not access internal CM editor instance.");
        return;
      }
      try {
        const coords = { x: evt.clientX, y: evt.clientY };
        const offset = cmEditor.posAtCoords(coords);
        this.debugLog("Date Selector Plugin: Click offset:", offset);
        if (offset === null || offset === void 0) {
          this.debugLog("Date Selector Plugin: Click position not found in editor.");
          return;
        }
        const pos = editor.offsetToPos(offset);
        this.debugLog("Date Selector Plugin: Click position (line, ch):", pos);
        if (!pos || typeof pos.line !== "number" || typeof pos.ch !== "number") {
          console.error("Date Selector Plugin: Invalid position object derived from offset:", pos);
          return;
        }
        const line = editor.getLine(pos.line);
        if (line === void 0) {
          console.error(`Date Selector Plugin: Could not get line content for line ${pos.line}`);
          return;
        }
        const { foundDate, start, end } = this.findDateAtPosition(line, pos.ch);
        if (foundDate) {
          this.debugLog(`Date Selector Plugin: Found date "${foundDate}" at [${start}-${end}] on line ${pos.line}`);
          evt.preventDefault();
          evt.stopPropagation();
          const initialDate = (0, import_obsidian.moment)(foundDate, "MM/DD/YY").format("YYYY-MM-DD");
          this.openDateModal(editor, initialDate, { line: pos.line, ch: start }, { line: pos.line, ch: end });
        } else {
          this.debugLog("Date Selector Plugin: No date found at click position.");
        }
      } catch (error) {
        console.error("Date Selector Plugin: Error during click handling:", error);
      }
    }
  }
  findDateAtPosition(line, ch) {
    const dateRegex = /\*([^*]+)\*/g;
    let match;
    const supportedFormats = [
      "MM/DD/YY",
      "MM-DD-YY",
      "YYYY-MM-DD",
      "DD/MM/YYYY",
      "MM/DD/YYYY",
      "MMM D, YYYY",
      "MMMM D, YYYY",
      "MMM D, YY",
      "MMMM D, YY"
    ];
    while ((match = dateRegex.exec(line)) !== null) {
      const start = match.index;
      const end = start + match[0].length;
      const datePart = match[1];
      if (ch >= start && ch <= end) {
        const parsed = (0, import_obsidian.moment)(datePart, supportedFormats, true);
        if (parsed.isValid()) {
          return {
            foundDate: datePart,
            // Return the date part (without asterisks)
            start,
            end
          };
        }
      }
    }
    return { foundDate: null, start: -1, end: -1 };
  }
};
var DateSuggester = class extends import_obsidian.EditorSuggest {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
  }
  onTrigger(cursor, editor, file) {
    const currentLine = editor.getLine(cursor.line);
    const sub = currentLine.substring(0, cursor.ch);
    this.plugin.debugLog(`DateSuggester: onTrigger: sub = "${sub}"`);
    const triggerCharPos = sub.lastIndexOf("@");
    if (triggerCharPos === -1) {
      this.plugin.debugLog("DateSuggester: onTrigger: '@' not found before cursor.");
      return null;
    }
    if (sub.length > triggerCharPos + 1 && sub[triggerCharPos + 1] === " ") {
      this.plugin.debugLog("DateSuggester: onTrigger: Space found immediately after '@'.");
      return null;
    }
    const query = sub.substring(triggerCharPos + 1);
    const completedDateRegex = /^\*(\d{1,2}\/\d{1,2}\/\d{2})\*/;
    if (completedDateRegex.test(query.trim())) {
      return null;
    }
    this.plugin.debugLog(`DateSuggester: onTrigger: sub = "${sub}"`);
    let finalQuery = query;
    const strictParsedDate = (0, import_obsidian.moment)(query, [
      "M/D/YY",
      "MM/DD/YY",
      "M-D-YY",
      "MM-DD-YY",
      "M/D/YYYY",
      "MM/DD/YYYY",
      "M-D-YYYY",
      "MM-DD-YYYY",
      "YYYY-MM-DD",
      "MMM D YY",
      "MMM D YYYY",
      "MMMM D YY",
      "MMMM D YYYY"
    ], true);
    if (strictParsedDate.isValid()) {
      this.plugin.debugLog(`DateSuggester: onTrigger: Strict parse succeeded for "${query}"`);
      finalQuery = strictParsedDate.format("*MM/DD/YY*");
    } else {
      const partialDateMatch = query.match(/^(\d{1,2})[\/-](\d{1,2})$/);
      if (partialDateMatch) {
        const currentYear = (0, import_obsidian.moment)().year();
        const paddedMonth = partialDateMatch[1].padStart(2, "0");
        const paddedDay = partialDateMatch[2].padStart(2, "0");
        const fullDateStr = `${paddedMonth}/${paddedDay}/${currentYear}`;
        const parsed = (0, import_obsidian.moment)(fullDateStr, "MM/DD/YYYY", true);
        if (parsed.isValid()) {
          finalQuery = parsed.format("*MM/DD/YY*");
          this.plugin.debugLog(`DateSuggester: onTrigger: Partial date parse succeeded for "${query}" as "${finalQuery}"`);
        } else {
          this.plugin.debugLog(`DateSuggester: onTrigger: Partial date parse failed for "${query}"`);
        }
      } else {
        this.plugin.debugLog(`DateSuggester: onTrigger: Strict parsing failed for "${query}". Passing raw query.`);
      }
    }
    const triggerInfo = {
      start: { line: cursor.line, ch: triggerCharPos },
      end: cursor,
      query: finalQuery
      // Pass formatted date or raw query
    };
    this.plugin.debugLog(`DateSuggester: onTrigger: returning triggerInfo =`, triggerInfo);
    return triggerInfo;
  }
  getSuggestions(context) {
    const query = context.query;
    const suggestions = [];
    this.plugin.debugLog(`DateSuggester: getSuggestions: context.query = "${query}"`);
    if (query.startsWith("*") && query.endsWith("*")) {
      suggestions.push({ label: `Insert date: ${query}`, isDate: true, dateValue: query });
      this.plugin.debugLog("DateSuggester: getSuggestions (Case 1): Suggesting pre-parsed date:", suggestions);
    }
    if (!query.trim()) {
      const todayRaw = (0, import_obsidian.moment)().format(this.plugin.settings.dateFormat);
      let todayInsert = todayRaw;
      if (!/^\*.*\*$/.test(todayInsert)) {
        todayInsert = `*${todayInsert}*`;
      }
      suggestions.push({ label: `Today: ${todayRaw}`, isDate: true, dateValue: todayInsert });
    }
    suggestions.push({ label: "Pick a date...", isDate: false });
    this.plugin.debugLog("DateSuggester: getSuggestions (Final): Returning suggestions:", suggestions);
    return suggestions;
  }
  renderSuggestion(suggestion, el) {
    el.setText(suggestion.label);
  }
  selectSuggestion(suggestion, evt) {
    var _a, _b, _c;
    const editor = (_a = this.context) == null ? void 0 : _a.editor;
    const startPos = (_b = this.context) == null ? void 0 : _b.start;
    const endPos = (_c = this.context) == null ? void 0 : _c.end;
    if (!editor || !startPos || !endPos) {
      console.error("Editor context not available in selectSuggestion");
      return;
    }
    this.close();
    if (suggestion.isDate && suggestion.dateValue) {
      const dateWithSpace = suggestion.dateValue + " ";
      editor.replaceRange(dateWithSpace, startPos, endPos);
      const newCursorPos = { line: startPos.line, ch: startPos.ch + dateWithSpace.length };
      editor.setCursor(newCursorPos);
    } else {
      this.plugin.openDateModal(editor, null, startPos, endPos);
    }
  }
};
var DateSelectorModal = class extends import_obsidian.Modal {
  // Store the picked date internally as YYYY-MM-DD
  constructor(app, initialDateYYYYMMDD, onSubmit) {
    super(app);
    this.initialDateYYYYMMDD = initialDateYYYYMMDD;
    this.onSubmit = onSubmit;
    this.selectedDateYYYYMMDD = (0, import_obsidian.moment)(this.initialDateYYYYMMDD, "YYYY-MM-DD", true).isValid() ? this.initialDateYYYYMMDD : (0, import_obsidian.moment)().format("YYYY-MM-DD");
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("date-selector-modal");
    contentEl.createEl("h2", { text: "Select a Date" });
    const dateInput = contentEl.createEl("input", { type: "date", cls: "date-selector-input" });
    dateInput.value = this.selectedDateYYYYMMDD;
    dateInput.addEventListener("change", (evt) => {
      this.selectedDateYYYYMMDD = evt.target.value;
    });
    contentEl.createEl("div", { attr: { style: "margin-top: 1rem;" } });
    new import_obsidian.Setting(contentEl).addButton((btn) => btn.setButtonText("Confirm Date").setCta().onClick(() => {
      if (!this.selectedDateYYYYMMDD || !(0, import_obsidian.moment)(this.selectedDateYYYYMMDD, "YYYY-MM-DD", true).isValid()) {
        console.error("Invalid date selected in modal:", this.selectedDateYYYYMMDD);
        return;
      }
      this.close();
      this.onSubmit(this.selectedDateYYYYMMDD);
    }));
    setTimeout(() => dateInput.focus(), 50);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var DateSelectorSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Date Selector Settings" });
    new import_obsidian.Setting(containerEl).setName("Date Format").setDesc("Choose the format for inserted dates.").addDropdown(
      (drop) => drop.addOption("MM/DD/YY", "02/25/25").addOption("MM-DD-YY", "02-25-25").addOption("YYYY-MM-DD", "2025-02-25").addOption("DD/MM/YYYY", "25/02/2025").addOption("MM/DD/YYYY", "02/25/2025").addOption("MMM D, YYYY", "Feb 25, 2025").addOption("MMMM D, YYYY", "February 25, 2025").setValue(this.plugin.settings.dateFormat).onChange(async (value) => {
        this.plugin.settings.dateFormat = value;
        await this.plugin.saveData(this.plugin.settings);
      })
    );
    new import_obsidian.Setting(containerEl).setName("Enable clicking on dates").setDesc("Allow clicking on formatted dates in the editor to update them.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableClickDates).onChange(async (value) => {
        this.plugin.settings.enableClickDates = value;
        await this.plugin.saveData(this.plugin.settings);
        this.display();
      })
    );
    containerEl.createEl("div", {
      text: "Requires plugin reload to take effect.",
      attr: { style: "color: #d43a3a; margin-bottom: 1em; font-size: 0.95em;" }
    });
    new import_obsidian.Setting(containerEl).setName("Enable @ date suggestions").setDesc("Show date suggestions when typing @ in the editor.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableAtSuggest).onChange(async (value) => {
        this.plugin.settings.enableAtSuggest = value;
        await this.plugin.saveData(this.plugin.settings);
        this.display();
      })
    );
    containerEl.createEl("div", {
      text: "Requires plugin reload to take effect.",
      attr: { style: "color: #d43a3a; margin-bottom: 1.5em; font-size: 0.95em;" }
    });
    new import_obsidian.Setting(containerEl).setName("Debug logging").setDesc("Enable debug logging to the console for troubleshooting.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.debugLogging).onChange(async (value) => {
        this.plugin.settings.debugLogging = value;
        await this.plugin.saveData(this.plugin.settings);
      })
    );
  }
};
